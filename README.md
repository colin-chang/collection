# Python 常用数据结构

## 1. 链表
链表(linked list)是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。

链表定位元素只能按照指针链，逐个查找，没有顺序表的索引结构。链表中CRUD操作的时间复杂度分别为，头插法`O(1)`,尾插法和定位插入`O(n)`,删除`O(n)`，修改和查询均为`O(n)`。

### 1.1 单向链表

![单链表](img/linkedlist-single.png)

单向链(Single Linked List)表也叫单链表，是链表中最简单的一种形式，单链表中的数据是以结点来表示的，每个结点的构成：元素 + 指针，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。

单链表中每个结点的存储地址是存放在其前趋结点next域中，而开始结点无前趋，故应设头指针`head`指向开始结点。链表由头指针唯一确定，单链表可以用头指针的名字来命名。终端结点无后继，故终端结点的指针域为空(None)。

### 1.2 单向循环链表
单向循环链表是单链表的另一种形式，其结构特点链表中最后一个结点的指针域不再是结束标记，而是指向整个链表的第一个结点，从而使链表形成一个环。

![单向循环链表](img/linkedlist-loop.png)

### 1.3 双向链表
双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。

![双向循环链表](img/linkedlist-double.png)

### 1.4 顺序表与链表
顺序表与链表同属线性表。

顺序表利用连续内存地址关联元素，可以迅速定位元素位置，查询和更新操作比较高效，但大量频繁的扩充元素则需要重新申请大块连续内存迁移所有的元素，执行效率偏低，删除操作则需要将删除元素后的所有元素前移。

链表通过节点指针串联元素，可以更好地利用非连续内存，但定位节点只能顺着指针连逐次查找，因此查询很更新操作比较低效。但新增节点则只需要申请新的内存挂在到现有链表中，删除元素则只需要修改前驱和后继节点的指针指向即可，因此新增和删除操作更加灵活高效。

在数据元素较少且规模相对固定，更多执行查询和更新操作的场景中，推荐使用稳定性更好的顺序表；相反的，数据规模未知且变动频繁，更多执行插入和删除操作的场景中推荐使用链表。

### 1.5 Python 链表

链表结构在不同的开发平台都有各自语言的版本实现，如链表在C#当中实现为`LinkedList<T>`，而Python并没有内建链表实现，需要我们自定义实现。[linkedlist.py](linklist.py)即是一种链表的自定义实现。

> 关于链表更多内容，请参阅 https://colin-chang.site/python/datastructure/linkedlist.html

## 2. 栈 / 队列
### 2.1 栈

栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

由于栈数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。

![栈示意图](img/stack.png)

栈在Python中也没有默认提供，需要我们自定义实现。[linearcollection.py](linearcollection.py)演示了中使用顺序表实现栈。

### 2.2 队列
队列(queue)是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。

队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。

![队列示意图](img/queue.jpg)

队列在Python中也没有默认提供，需要我们自定义实现。[linearcollection.py](linearcollection.py)演示了中使用顺序表实现队列。

### 2.3 双端队列

双端队列（deque，全名double-ended queue），是一种具有队列和栈的性质的数据结构。双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。双端队列可以在队列任意一端入队和出队。Redis的List类型就是双端队列。

![双端队列示意图](img/deque.jpg)

双端队列在Python中也没有默认提供，需要我们自定义实现。[linearcollection.py](linearcollection.py)演示了中使用顺序表实现双端队列。

> 关于栈和队列的更多内容，请参阅 https://colin-chang.site/python/datastructure/stackqueue.html

## 3. 二叉树
### 3.1 树
树(tree)是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。

树具有以下的特点： 
* 每个节点有零个或多个子节点；
* 没有父节点的节点称为根节点；
* 每一个非根节点有且只有一个父节点；
* 除了根节点外，每个子节点可以分为多个不相交的子树；

![树状图](img/tree.png)

术语|含义
:-|:-
节点的度|一个节点含有的子树的个数称为该节点的度
树的度|一棵树中，最大的节点的度称为树的度
叶节点或终端节点|度为零的节点
父节点|若一个节点含有子节点，则这个节点称为其子节点的父节点
子节点|一个节点含有的子树的根节点称为该节点的子节点
兄弟节点|具有相同父节点的节点互称为兄弟节点
节点层次|从根开始定义起，根为第1层，根的子节点为第2层，以此类推
树高度或深度|树中节点的最大层次
堂兄弟节点|父节点在同一层的节点互为堂兄弟
节点祖先|从根到该节点所经分支上的所有节点
子孙|以某节点为根的子树中任一节点都称为该节点的子孙
森林|由m（m>=0）棵互不相交的树的集合称为森林


树有以下常用分类。
* **有序树**。树中任意节点的子节点之间有顺序关系，这种树称为有序树；
    * **二叉树**。每个节点最多含有两个子树的树称为二叉树；
        * **完全二叉树**。除最后一层外，其它各层的节点数目均已达最大值，且最后一层从左向右连续地紧密排列，这样的二叉树被称为完全二叉树
        * **满二叉树**。所有叶节点都在最底层的完全二叉树。如下图所示。
        * **平衡二叉树**(AVL树)。当且仅当任何节点的两棵子树的高度差不大于1的二叉树
        * **排序二叉树**(二叉查找树，也称二叉搜索树、有序二叉树）
    * **霍夫曼树**(用于信息编码)。带权路径最短的二叉树称为哈夫曼树或最优二叉树
    * **B树**。一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树
* **无序树**。树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树。

![满二叉树](../img/datastructure/fullBinaryTree.png)

以下业务场景中，需要是哟功能树结构：
* xml，html结构
* 路由协议
* mysql 数据库索引
* 文件系统目录结构
* 很多经典AI算法使用树搜索。机器学习中的`decision tree`也是树结构

### 3.2 二叉树
二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”(left subtree)和“右子树”(right subtree)。

二叉树有以下特性：
* 第 n 层最多有 2<sup>n-1</sup> 个结点(n>0)
* 深度为 n 的二叉树最多有 2<sup>n</sup>-1 个结点(n>0)
* 叶结点数为 n0，而度数为2的结点总数为 n2，则 n0 = n2+1
* 具有 n 个结点的完全二叉树的深度为 log<sub>2</sub>(n+1)

### 3.3 构建二叉树
一般情况下，二叉树多使用完全二叉树方式存储，如下图就是一个完全二叉树。

<img id="cbt" src="img/completeBinaryTree.png" alt="完全二叉树" />

我们可以仿照链表的数据结构方式，构建完全二叉树。我们首先构建一个只有根节点的二叉树，然后逐个挂载节点。定义一个待处理节点队列(默认加入根节点)。出队一个待分析节点，先判断其左子树是否为None，如果是则直接挂载新节点并退出，否则判断其柚子树是否为None，如果是则直接挂载新节点并退出，否则将其左右节点都入队。然后重复以上操作直到挂载成功。详细代码参见 [linearlist.py](linearlist.py)

### 3.4 遍历二叉树
树的遍历是树的一种重要的运算。所谓遍历是指对树中所有结点的信息的访问，即依次对树中每个结点访问一次且仅访问一次，我们把这种对所有节点的访问称为遍历（traversal）。那么树的两种重要的遍历模式是深度优先遍历和广度优先遍历,深度优先一般用递归，广度优先一般用队列。

#### 3.4.1 广度优先遍历
广度优先遍历也称层次遍历，其策略是从树的根节点开始，从上到下从从左到右遍历整个树的节点，与构建完全二叉树的思路一致,此处不再赘述。

[上图二叉树](#cbt)，广度优先遍历结果为 `ABCDEFGHIJ`

#### 3.4.2 深度优先遍历
深度遍历根据访问根节点的次序不同分为三种方法，先序遍历(preorder)，中序遍历(inorder)和后序遍历(postorder)

* 先序遍历。先访问根节点，然后递归使用先序遍历访问左子树，再递归使用先序遍历访问右子树。
* 中序遍历。递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树。
* 后序遍历。先递归使用后序遍历访问左子树和右子树，最后访问根节点。

遍历操作详细代码参见 [linearlist.py](linearlist.py)

[上图二叉树](#cbt)，先序遍历结果为 `ABDHIEJCFG`，中序遍历结果为 `HDIBJEAFCG`，后序遍历结果为 `HIDJEBFGCA`。

#### 3.4.3 深度遍历确定唯一完全二叉树
二叉树遍历过程中，所有节点会作为一个序列输出，左右子树的节点是同级的且有序的(先左后右)，如果可以确定根节点，那就可以使用根节点递归划分左右子树来，这样就可以唯一确定、一棵二叉树树的结构。

简单讲，只要确定中序遍历结果，结合先序或后序遍历结果任意一种，就能确定一个二叉树。

如：有先序遍历结果为 `ABDHIEJCFG`，中序遍历结果为 `HDIBJEAFCG`。我们来尝试构建完全二叉树。

先序规则为根左右，首个节点`A`就是树的根节点，依此中序结果以`A`为界分为`HDIBJE`(左子树)和`FCG`(右子树)。先序第二个节点`B`为左子树节点`HDIBJE`的根节点，以`B`为界分为`HDI`(左子树)和`JE`(右子树)。依此类推，逐层确定根节点，最终分组小于等于2时，每组一个元素，根节点左侧为左树，右侧为右树，这样就可以确定如[上图](#cbt)所示的二叉树。
